<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lake Tahoe Precipitation</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    #controls { display: flex; gap: 16px; align-items: center; margin-bottom: 10px; flex-wrap: wrap; }
    #status { font-size: 12px; opacity: .7; }
    #1\.3\.d_Precip { width: 100%; height: 600px; }
    .spacer { flex: 1; }
  </style>
</head>
<body>
  <div id="controls">
    <label>
      <input type="checkbox" id="excludeSummer" />
      Exclude May–September
    </label>
    <div class="spacer"></div>
    <span id="status">Loading…</span>
  </div>

  <!-- Keep the same div id you used in Python -->
  <div id="1.3.d_Precip"></div>

  <script>
    // ---- CONFIG ----
    const LAYER_URL = "https://maps.trpa.org/server/rest/services/LTinfo_Climate_Resilience_Dashboard/MapServer/145";
    const MIN_YEAR = 1987; // match your Python filter

    // Fields we need
    const OUT_FIELDS = [
      "OBJECTID",
      "Year",
      "Full_Day_Total_Precip_mm",
      "Pct_of_Precip_as_Rain",
      "Pct_of_Precip_as_Snow",
      "Month_Year"
    ].join(",");

    // Colors to match your Python sequence order: [% Snow, % Rain]
    const COLOR_SNOW = "#BFD7ED";
    const COLOR_RAIN = "#60A3D9";

    // --- DOM ---
    const chartDivId = "1.3.d_Precip";
    const statusEl = document.getElementById("status");
    const excludeSummerEl = document.getElementById("excludeSummer");

    // ---- HELPERS ----
    const toNum = v => {
      const n = parseFloat(v);
      return Number.isFinite(n) ? n : 0;
    };

    function monthFromMonthYear(val) {
      // Tries to read last two digits as month ("YYYYMM" or "YYYY-MM" or "YYYY/MM")
      const s = (val ?? "").toString().trim();
      const m = s.match(/(\d{2})$/);
      return m ? parseInt(m[1], 10) : null;
    }

    function fmtPct(val) {
      return Math.round(val);
    }

    // ---- DATA FETCH (with pagination) ----
    async function getLayerInfo(url) {
      const r = await fetch(`${url}?f=json`);
      if (!r.ok) throw new Error(`Layer info HTTP ${r.status}`);
      return r.json();
    }

    async function queryPage(url, offset, pageSize) {
      const qs = new URLSearchParams({
        f: "json",
        where: "1=1",
        outFields: OUT_FIELDS,
        returnGeometry: "false",
        orderByFields: "OBJECTID",
        resultOffset: String(offset),
        resultRecordCount: String(pageSize)
      });
      const r = await fetch(`${url}/query?${qs.toString()}`);
      if (!r.ok) throw new Error(`Query HTTP ${r.status}`);
      return r.json();
    }

    async function fetchAllFeatures(url) {
      statusEl.textContent = "Loading layer info…";
      const info = await getLayerInfo(url);
      const pageSize = Math.max(200, info.maxRecordCount || 1000); // be generous but safe
      let offset = 0;
      let all = [];

      while (true) {
        statusEl.textContent = `Fetching records ${offset + 1} – ${offset + pageSize}…`;
        const page = await queryPage(url, offset, pageSize);
        const features = page.features || [];
        all = all.concat(features);
        // Stop when no more features OR the server says we didn't exceed its transfer limit
        if (!features.length || !page.exceededTransferLimit) break;
        offset += pageSize;
      }

      statusEl.textContent = `Loaded ${all.length.toLocaleString()} rows. Processing…`;
      return all.map(f => f.attributes || {});
    }

    // ---- TRANSFORM (mirror your Python) ----
    function buildYearly(data, { excludeSummer = false } = {}) {
      // 1) Optional filter for May–September based on Month_Year
      const filtered = data.filter(row => {
        const year = toNum(row.Year);
        if (!Number.isFinite(year) || year < MIN_YEAR) return false;

        if (excludeSummer) {
          const mm = monthFromMonthYear(row.Month_Year);
          if (mm !== null && mm >= 5 && mm <= 9) return false;
        }
        return true;
      });

      // 2) Per-row derived daily rain/snow from % fields
      //    Daily_Precip_Rain_mm = Full_Day_Total_Precip_mm * (Pct_of_Precip_as_Rain/100)
      //    Daily_Precip_Snow_mm = Full_Day_Total_Precip_mm * (Pct_of_Precip_as_Snow/100)
      const byYear = new Map();
      for (const r of filtered) {
        const y = toNum(r.Year);
        const total = toNum(r.Full_Day_Total_Precip_mm);
        const pctRain = toNum(r.Pct_of_Precip_as_Rain);
        const pctSnow = toNum(r.Pct_of_Precip_as_Snow);

        const dailyRain = total * (pctRain / 100);
        const dailySnow = total * (pctSnow / 100);

        if (!byYear.has(y)) byYear.set(y, { year: y, rainSum: 0, snowSum: 0 });
        const agg = byYear.get(y);
        agg.rainSum += dailyRain;
        agg.snowSum += dailySnow;
      }

      // 3) Aggregate to yearly totals and compute percents
      const rows = Array.from(byYear.values())
        .sort((a, b) => a.year - b.year)
        .map(({ year, rainSum, snowSum }) => {
          const total = rainSum + snowSum;
          const pctRain = total ? (rainSum / total) * 100 : 0;
          const pctSnow = total ? (snowSum / total) * 100 : 0;
          return { Year: year, "% Rain": pctRain, "% Snow": pctSnow };
        });

      return rows;
    }

    // ---- CHART ----
    function drawChart(rows) {
      // Ensure stable year order and aligned series arrays
      const years = rows.map(r => r.Year);
      const pctSnow = rows.map(r => r["% Snow"]);
      const pctRain = rows.map(r => r["% Rain"]);

      const traceSnow = {
        x: years,
        y: pctSnow,
        name: "% Snow",
        type: "bar",
        marker: { color: COLOR_SNOW },
        hovertemplate: "%{y:.0f}%<extra></extra>"
      };

      const traceRain = {
        x: years,
        y: pctRain,
        name: "% Rain",
        type: "bar",
        marker: { color: COLOR_RAIN },
        hovertemplate: "%{y:.0f}%<extra></extra>"
      };

      const layout = {
        title: "Lake Tahoe Precipitation",
        barmode: "stack",
        margin: { t: 40 },
        xaxis: {
          title: "Year",
          type: "category",
          categoryorder: "array",
          categoryarray: years // lock the axis to full ordered year list
        },
        yaxis: { title: "% of Precipitation", ticksuffix: "%" },
        hovermode: "x unified",
        legend: {
          orientation: "h",
          entrywidth: 100,
          yanchor: "bottom",
          y: 1.05,
          xanchor: "right",
          x: 1
        }
      };

      Plotly.newPlot(chartDivId, [traceSnow, traceRain], layout, { responsive: true });
    }

    // ---- ORCHESTRATION ----
    let rawFeatures = null;

    async function refreshChart() {
      try {
        statusEl.textContent = "Processing…";
        const rows = buildYearly(rawFeatures, { excludeSummer: excludeSummerEl.checked });
        drawChart(rows);
        if (rows.length) {
          const yrMin = rows[0].Year;
          const yrMax = rows[rows.length - 1].Year;
          statusEl.textContent = `Showing ${rows.length} years (${yrMin}–${yrMax})${excludeSummerEl.checked ? " • May–Sep excluded" : ""}.`;
        } else {
          statusEl.textContent = "No data for the selected filters.";
        }
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Error processing data (see console).";
      }
    }

    (async function init() {
      try {
        rawFeatures = await fetchAllFeatures(LAYER_URL);
        await refreshChart();
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Error loading data (see console).";
      }
    })();

    excludeSummerEl.addEventListener("change", refreshChart);
  </script>
</body>
</html>
