<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Deck.gl HexagonLayer â€” Weighted Hexes</title>
<script src="https://unpkg.com/maplibre-gl@3.3.1/dist/maplibre-gl.js"></script>
<link href="https://unpkg.com/maplibre-gl@3.3.1/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/deck.gl@latest/dist.min.js"></script>
<script type="module" src="https://js.arcgis.com/calcite-components/2.6.0/calcite.esm.js"></script>
<link rel="stylesheet" href="https://js.arcgis.com/calcite-components/2.6.0/calcite.css" />
<style>
  html, body, #map { margin:0; height:100%; width:100%; }
  #controls {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(255,255,255,0.95);
    padding: 12px;
    border-radius: 8px;
    width: 280px;
    z-index: 10;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  }
  calcite-slider { width: 100%; margin-top: 4px; }
  calcite-button { margin-top: 8px; width: 100%; }
</style>
</head>
<body>

<div id="controls">
  <calcite-label>Density <calcite-slider id="density" min="0" max="1" step="0.01" value="0.33"></calcite-slider></calcite-label>
  <calcite-label>Active Transport <calcite-slider id="active" min="0" max="1" step="0.01" value="0.33"></calcite-slider></calcite-label>
  <calcite-label>Transit <calcite-slider id="transit" min="0" max="1" step="0.01" value="0.34"></calcite-slider></calcite-label>
  <calcite-button id="reset" appearance="solid" color="red">Reset Equal Weights</calcite-button>
  <calcite-label>Hex Height <calcite-slider id="hexHeight" min="10" max="500" step="10" value="50"></calcite-slider></calcite-label>
  <div id="status" style="margin-top:6px; font-size:12px; color:#333;">Loading data...</div>
</div>

<div id="map"></div>

<script>
(async function() {
  const serviceUrl = "https://services5.arcgis.com/fXXSUzHD5JjcOt1v/arcgis/rest/services/PIA_Index/FeatureServer/1/query";
  const outFields = ["density_index_preprocessed","bike_ped_index_preprocessed","Transit_Index_PREPROCESSED","latitude","longitude"];
  const pageSize = 1000;
  let allPoints = [];

  const densitySlider = document.getElementById("density");
  const activeSlider  = document.getElementById("active");
  const transitSlider = document.getElementById("transit");
  const resetBtn = document.getElementById("reset");
  const hexHeightSlider = document.getElementById("hexHeight");
  const status = document.getElementById("status");

  let weights = {density:0.33, active:0.33, transit:0.34};
  let elevationScale = parseFloat(hexHeightSlider.value);

  // Blue color scale
  const stops = [
    {v:0, rgba:[200,230,255,102]},
    {v:0.25, rgba:[150,210,255,153]},
    {v:0.5, rgba:[100,180,255,191]},
    {v:0.75, rgba:[50,150,255,230]},
    {v:1, rgba:[0,100,255,255]}
  ];

  function interpColor(v){
    v = Math.max(0, Math.min(1, v));
    let lo=stops[0], hi=stops[stops.length-1];
    for(let i=0;i<stops.length-1;i++){
      if(v >= stops[i].v && v <= stops[i+1].v){ lo=stops[i]; hi=stops[i+1]; break; }
    }
    const t=(v-lo.v)/(hi.v-lo.v||1);
    return lo.rgba.map((c,i)=>Math.round(c*(1-t) + hi.rgba[i]*t));
  }

  status.innerText = "Fetching data...";

  async function fetchAllFeatures(){
    let offset = 0;
    let fetched = [];
    while(true){
      const url = `${serviceUrl}?where=1=1&outFields=${outFields.join()}&outSR=4326&f=geojson&resultOffset=${offset}&resultRecordCount=${pageSize}`;
      const res = await fetch(url);
      const data = await res.json();
      if(!data.features || data.features.length === 0) break;
      fetched = fetched.concat(data.features);
      offset += data.features.length;
      status.innerText = `Loaded ${offset} records...`;
    }
    return fetched;
  }

  try{
    const features = await fetchAllFeatures();
    allPoints = features.map(f => ({
      position: [
        parseFloat(f.properties.longitude),
        parseFloat(f.properties.latitude)
      ],
      density: +f.properties.density_index_preprocessed || 0,
      active: +f.properties.bike_ped_index_preprocessed || 0,
      transit: +f.properties.Transit_Index_PREPROCESSED || 0
    }))
    .filter(p => !isNaN(p.position[0]) && !isNaN(p.position[1]) &&
                 p.position[1] >= -90 && p.position[1] <= 90 &&
                 p.position[0] >= -180 && p.position[0] <= 180);
    status.innerText = `Loaded ${allPoints.length} points.`;
  }catch(err){
    console.error(err);
    status.innerText = "Failed to fetch data.";
    return;
  }

  // Normalize points once
  const maxD = Math.max(...allPoints.map(p=>p.density));
  const maxA = Math.max(...allPoints.map(p=>p.active));
  const maxT = Math.max(...allPoints.map(p=>p.transit));
  const normalizedPoints = allPoints.map(p=>({
    ...p,
    normDensity: maxD ? p.density/maxD : 0,
    normActive: maxA ? p.active/maxA : 0,
    normTransit: maxT ? p.transit/maxT : 0
  }));

  const map = new maplibregl.Map({
    container:'map',
    style:'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
    center:[-120,39.1],
    zoom:8
  });

  const deckgl = new deck.DeckGL({
    container:'map',
    initialViewState:{longitude:-120, latitude:39.1, zoom:8, pitch:40, bearing:0},
    controller:true,
    layers:[]
  });

  function renderHex(){
    const layer = new deck.HexagonLayer({
      id:'hex-layer',
      data: normalizedPoints,
      getPosition:d=>d.position,
      radius:500,
      extruded:true,
      elevationScale:elevationScale,
      getElevationWeight:d => (d.normDensity*weights.density + d.normActive*weights.active + d.normTransit*weights.transit) || 0,
      elevationAggregation:'MEAN',
      getColorWeight:d => (d.normDensity*weights.density + d.normActive*weights.active + d.normTransit*weights.transit) || 0,
      colorAggregation:'MEAN',
      getFillColor:w => interpColor(w),
      pickable:true,
      onHover: info => {
        if(info.object){
          const val = (info.object.colorValue||0).toFixed(2);
          const count = info.object.points.length;
          status.innerText = `Hex mean value: ${val}, Points: ${count}`;
        }
      }
    });
    deckgl.setProps({layers:[layer]});
  }

  function updateWeights(changed){
    let d = parseFloat(densitySlider.value);
    let a = parseFloat(activeSlider.value);
    let t = parseFloat(transitSlider.value);

    // Live-sum logic
    const total = d + a + t;
    if(total === 0) { d = a = t = 1/3; } 
    else if(changed === 'density'){ const scale=(1-d)/(a+t); a*=scale; t*=scale; }
    else if(changed === 'active'){ const scale=(1-a)/(d+t); d*=scale; t*=scale; }
    else if(changed === 'transit'){ const scale=(1-t)/(d+a); d*=scale; a*=scale; }

    densitySlider.value = d.toFixed(2);
    activeSlider.value = a.toFixed(2);
    transitSlider.value = t.toFixed(2);

    weights.density = d;
    weights.active = a;
    weights.transit = t;

    renderHex();
  }

  densitySlider.addEventListener("calciteSliderInput", ()=>updateWeights('density'));
  activeSlider.addEventListener("calciteSliderInput", ()=>updateWeights('active'));
  transitSlider.addEventListener("calciteSliderInput", ()=>updateWeights('transit'));

  resetBtn.addEventListener("click", ()=>{
    densitySlider.value = activeSlider.value = transitSlider.value = 0.33;
    updateWeights();
  });

  hexHeightSlider.addEventListener("calciteSliderInput", ()=>{
    elevationScale = parseFloat(hexHeightSlider.value);
    renderHex();
  });

  // Initial render
  renderHex();

})();
</script>

</body>
</html>
